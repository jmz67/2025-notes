对文件做拷贝，打印，搜索，排序，统计或类似事情的程序都有一个差不多的程序结构：一个处理输入的循环，在每个元素上执行计算处理，在处理的同时或最后产生输出。我们会展示一个名为 dup 的程序的三个版本；灵感来自于 Unix 的 uniq 命令，其寻找相邻的重复行。该程序使用的结构和包是个参考范例，可以方便地修改。

dup 的第一个版本打印标准输入中多次出现的行，以重复次数开头。该程序将引入 if 语句，map 数据类型以及 bufio 包。

```go
// Dup1 prints the text of each line that appears more than 
// once in the standard input, preceded by its count 

package main 

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    count := make(map[string]int)
    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        counts[input.Text()]++
    }
    // Note: ignoring potential errors from input.Err
    for line, n := range counts {
        if n > 1 {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
}
```

map 存储了键值的集合，对集合元素，提供常数时间的存，取或测试操作。键可以是任意类型，只要其值可以使用 == 运算符比较，最常见的例子是字符串；值则可以是任意类型。这个例子中的键是字符串，值是整数。内置函数 make 创建空 map ，此外，它还有别的作用。

每次 dup 读取一行输入，该行被当作